#pragma config(Sensor, in6,    ir1,            sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl6,  tabby1,         sensorTouch)
#pragma config(Sensor, dgtl7,  tabby2,         sensorTouch)
#pragma config(Sensor, dgtl4,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, I2C_2,  encoder2,       sensorNone)
#pragma config(Motor,  port2,           kindofbroken,  tmotorNone, openLoop)
#pragma config(Motor,  port3,           broken,        tmotorNone, openLoop)
#pragma config(Motor,  port4,           motor2,        tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          armAltitude,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * 2019-03-17
 */

//from LightDetector.c
typedef enum T_State {
	LIGHT_SEEN = 0,
	LIGHT_GONE
};
const int beacon_threshold = 300;
//from LightDetector.c ^ for the IR sensor

//states for fullExecution()
typedef enum RobotState {
	SEARCHING = 0,
	ADJUST_SEARCH_POSITION,
	HIT_WALL_SEARCH,
	HIT_WALL_EXIT,
	APPROACHING,
	ATTACHING_CABLE,
	BEST_EXIT,
	EXITING,
	FINISHED
};

/*Clearly labeled constraints   should  indicate expected  sensor  readings  for  different
  conditions such as your robot?s proximity sensor reading when the robot is near enough
  to the beacon for target pick up
 */
int propor_proximity_to_beacon = 22; //cm reading from Ultrasonic Sensor
int max_proximity_to_wall;	//smallest ultrasonic sensor reading to not run into a wall

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input

bool tabby1_pushed = false;
bool tabby2_pushed = false;

int forwardsSpeed = -30;
int backwardsSpeed = 30;
int armSpeed = 50;
int distanceThreshhold = 22; //distance to object in front of robot. 22 cm for good beacon positioning
int DEGREES90 = 2000; //amount of time to turn 90 degrees set to 2000?
int rotationSpeed;
//led = 0 is on. 1 is off


/*	monitorInput()taken from lab 2 code
 *
 *  Used to flag button inputs
 *       - this avoids errors caused by program recognizing input, taking action, and
 *         reading input again before button is released
 */
void monitorInput(){
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }

  if(SensorValue(tabby1) && !tabby1_pushed){
  	tabby1_pushed = true;
	}

	if(SensorValue(tabby2) && !tabby2_pushed){
  	tabby2_pushed = true;
	}
}

/* monitorLight() - taken from lab code
 * Perform processing of measurements.
 * Should be called with rate of at least 20 Hertz for proper detection of puck.
 * Purpose: determines if the robot is facing the beacon
 */
int monitorLight(){
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = 4096 - SensorValue[ir1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}


 // <Basic Movement And Signals> //
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

/*	driveForwards()
 *	drive forwards for a set amount of time
 * 40 speed for 2700 time is about a meter
 */
void driveForwards(int amountToMove){
	resetMotorEncoder(motor1);

  motor[motor1] = forwardsSpeed;
 	motor[motor2] = forwardsSpeed - 13;
	wait1Msec(amountToMove);

  motor[motor1] = motor[motor2] = 0;
  button1_pushed = button2_pushed = false;
  resetMotorEncoder(motor1);
}

/*	DriveBackwards()
 *	Drive backwards for a set amount of time
 */
void driveBackwards(int amountToMove){
		resetMotorEncoder(motor1);


  	      motor[motor1] = motor[motor2] = backwardsSpeed;
//  	      motor[motor2] = backwardsSpeed;
  	      wait1Msec(amountToMove);

        motor[motor1] = motor[motor2] = 0;
        button1_pushed = button2_pushed = false;
        resetMotorEncoder(motor1);
}

/*	turnRight()
 *	Purpose: Robot turns for a set amount of time. 20 and -30 speed with 3600 time equate to a 90 degree turn
 *	Method: one motor forwards, one backwards
 */
void turnRight(int degreesToMove){

	motor[motor1] = 30;//forwards
	motor[motor2] = -30;//backwards
	wait1Msec(degreesToMove);

	motor[motor1] = 0;
	motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}

/* turnLeft()
 * opposite of turn right
 */
void turnLeft(int degreesToMove){
	motor[motor1] = -25;//left motor backwards
	motor[motor2] = 25;//forwards
	wait1Msec(degreesToMove);

    motor[motor1] = motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}

/* raiseArm()
 * Purpose: raises the arm holding the connection point of the cable for a set amount of time
 */
void raiseArm(int amountToMove){
	resetMotorEncoder(armAltitude);

  	motor[armAltitude] = armSpeed;
  	wait1Msec(amountToMove);

    motor[armAltitude] = 0;
    button1_pushed = button2_pushed = false;
    resetMotorEncoder(armAltitude);
}//raiseArm

/* lowerArm()
 * Purpose: Oposite as raiseArm
 */
void lowerArm(int amountToMove){
	resetMotorEncoder(armAltitude);

	motor[armAltitude] = -armSpeed;
  wait1Msec(amountToMove);

   motor[armAltitude] = 0;
   button1_pushed = button2_pushed = false;
   resetMotorEncoder(armAltitude);
}

/* connectCable()
 * runs through connecting the cable
 */
void connectCable(){
	//lower arm then back away so cable doesnt get stuck
	//*WARNING* cable gets stuck sometimes
	wait1Msec(1000);
	lowerArm(250);
	wait1Msec(1000);
	driveBackwards(1000);
	wait1Msec(1000);
	lowerArm(70);//lower arm after backing away from target
	wait1Msec(1000);
	button1_pushed = button2_pushed = false;
}


/* signalFoundBeacon()
 * routine or light to signal success
 * raises and lowers arm 2x
 * call when ir found beacon and distance is too far still
 */
void signalFoundBeacon(){
		SensorValue[led1] = 0;		//do I want to use these?
}

void signalInPositionForConnection(){
		SensorValue[led2] = 0;
}


 // <Robot Running Functions> //
//~~~~~~~~~~~~~~~~~~~~~~~~~~~//

/* getToTarget()
 * Purpose: Find and approach the target.
 * Used for milestone 3
 * Currently keeping to reference dealing with hitting walls code
 */
void getToTarget(){	//temperary for referencing

/*
TODO
start turning. if a wall is getting close then turn the other way so it doesnt face the corner. if no beacon still found then turn all the way around
*/
	T_State robot_state = LIGHT_GONE;
	int  beacon_level;
	button1_pushed = button2_pushed = false;
	tabby1_pushed = tabby2_pushed = false;

	//kill switch
	if(button2_pushed){
		return;
	}

	while( true ) {
		monitorInput();//for buttons

		// Update sensor values (must be called at least 20 times a second for proper performance).
		beacon_level = monitorLight();	//ir sensor



		switch( robot_state ) {
		case LIGHT_GONE://turn until beacon is seen
			turnLeft(20);																				//*WARNING* possibly just activate motor rather than calling turnLeft(). turnLeft() might mess with the neccisary timing of reading light

			//handle hitting walls
			if(tabby1_pushed || tabby2_pushed){
				motor[motor1] = motor[motor2] = 0;
				driveForwards(1000);
				tabby1_pushed	= tabby2_pushed = false;
			}
			//if too close to anything, back up
			if(SensorValue(ultrasonic) < 13 && SensorValue(ultrasonic) > 0) {
					driveBackwards(1000);
			}

			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_SEEN;
				} else {
				robot_state = LIGHT_GONE;
			}
			break;
		case LIGHT_SEEN://stop turning, signal success, approach beacon, end facing the beacon at beacon
			signalFoundBeacon();
			//approach beacon
			//approachBeacon(); function deleted
			break;
		default:
			// This should never happen.
			robot_state = LIGHT_GONE;

		} // switch( robot_state)

	}  // while(true)

}

/* detectProperDistance()
 * Purpose: run to test if the robot can detect the target
 * Details: leds turn on when the robot can see the target. Front led = too too far. Back led = too close
 */
//Note: led = 0 is on. 1 is off
void detectProperDistance(){ //for testing purposes
	int  beacon_level;
	SensorValue[led1] = 1;
	SensorValue[led2] = 1;

	while(true){
		beacon_level = monitorLight();

		//if seeing beacon
		if(beacon_level > beacon_threshold){//beacon_threshold == 500
			//SensorValue[led1] = 1;
			if (SensorValue[ultrasonic] > distanceThreshhold + 1){
					//too far led 1 on
				SensorValue[led1] = 0;
				SensorValue[led2] = 1;
			}
			else if (SensorValue[ultrasonic] < distanceThreshhold - 1){
				//too close led 2 on
				SensorValue[led1] = 1;
				SensorValue[led2] = 0;
			}
			else {//(SensorValue[ultrasonic] == distanceThreshhold){
				//just right
			SensorValue[led1] = 0;
			SensorValue[led2] = 0;
				//signalHitWall();
			}

			//SensorValue[led1] = 1;
			//SensorValue[led2] = 1;
		}//if seeing beacon
		else{
			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
	  }

/*Used for testing just the ir sensor. A binary on or off LEDs
		else{
			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
		}
*/
	}//while

	SensorValue[led1] = 0;
	SensorValue[led2] = 0;
}

/* openIRSearch()
 * Purpose: Searches for the target object with one IR sensor with nothing to restrict the IR sensors field of view
 * Possibly impliment instead of default search (with straw around IR sensor) to increase range of the sensor
 * possibly just make the robot turn more after seeing the beacon. Will have conflict if the robot starts facing the beacon
 */


/* fullExecution()
 * Purpose: locate and attatch the cable to the target fully.
 */
void fullExecution(){
	bool jobDone = false; //for while loop
	RobotState robot_state = SEARCHING; //for switch case default SEARCHING
	int amountTurned = 0; //for searching
	int exitDistance = 0; //for moving away from cable after connection
	int beacon_level;
	int domTimer = 0;

	wait1Msec(100);

	while(!jobDone){
		button1_pushed = button2_pushed = false;
		monitorInput();//for buttons

/*		if(button1_pushed){
			button1_pushed = false;
			wait1Msec(3000);
		}
*/
		switch(robot_state){
			case(SEARCHING):
			//rotate until target seen. If no target with 360 roation then move across arena more.
				//rotate
				turnLeft(2);
				amountTurned += 1;//degrees turned in one turnLeft(2)

				//detect target
				// Update sensor values (must be called at least 20 times a second for proper performance).
				beacon_level = monitorLight();	//ir sensor difference update
				if ( beacon_level > beacon_threshold ) {	//light seen
					turnRight(15);
//					turnLeft(1);
					wait1Msec(1000);
					robot_state = APPROACHING;
				}//if

				//detect if rotated over 360 degrees
				if (amountTurned > 360){
					robot_state = ADJUST_SEARCH_POSITION;
					amountTurned = 0;
				}

				//detect wall hit
				if(SensorValue[ultrasonic] < 10 && SensorValue[ultrasonic] > 0){								//to be implimented---------------------------------
					robot_state = HIT_WALL_SEARCH;
				}
				break;

			case(ADJUST_SEARCH_POSITION):
				//drive forward. Do not run into stuff
				//font led blinking

				for(int k = 0; k < 100; k++){
					SensorValue[led1] = 0;		//blink on front led
//					driveForwards(20);
					//detect walls
					if(SensorValue(ultrasonic) < 13 && SensorValue[ultrasonic] > 0){	//might need adjusting------------------------------
						driveBackwards(100);
						turnLeft(DEGREES90);
					}
					SensorValue[led1] = 1;
				}//for
				robot_state = SEARCHING;
				break;

			case(HIT_WALL_SEARCH):
			//backup 20? cm
				driveBackwards(500);
				robot_state = SEARCHING;
				break;

			case(HIT_WALL_EXIT):
				//backup 20? cm
				driveBackwards(500);
				robot_state = EXITING;
				break;

			case(APPROACHING)://approach while checking for target lost

				//if too far from target
				//front led on
				domTimer++;
				//100 time in Ms
				if ( domTimer > 2000 )  {
					wait1Msec(1000);
					robot_state = SEARCHING;
					domTimer = 0;
				}


//actual program//
				if(SensorValue(ultrasonic) > 19){
					SensorValue[led1] = 0;
					driveForwards(2);
				}
				//if too close to target
				//back led on
				else if(SensorValue(ultrasonic) < 17 && SensorValue(ultrasonic) > 0){
					SensorValue[led2] = 0;
					driveBackwards(5);
				}
				//if reached target
				else{
//					SensorValue[led1] = SensorValue[led2] = 0; //both led on
					//wait to see if resting in proper position
					//wait1Msec(500);
//					SensorValue[led1] = SensorValue[led2] = 1; //both led off

					//if not in correct position
					if(SensorValue(ultrasonic) < 17 || SensorValue(ultrasonic) > 19) {
						break;
					}
					//if lost beacon//
				beacon_level = monitorLight();	//ir sensor difference update
				if ( beacon_level > beacon_threshold) {	//light lost
					wait1Msec(300);
					driveBackwards(500);
					robot_state = SEARCHING;
				}

					//else if still in proper position
					robot_state = ATTACHING_CABLE;
				}
				break;
//ACTUAL program end



/*some botched program
			driveBackwards(5);
			break;
//Some botched program end
*/

			case(ATTACHING_CABLE):
			//connect cable
				connectCable();
				robot_state = BEST_EXIT;
				break;

			case(BEST_EXIT):
			//get away from target without being connected or tangled with the cable
				//turn left 90, if wall is within 50cm,turn right, drive away
				turnLeft(DEGREES90);

				//raise arm here to avoid reading the arm as a distance. Make sure arm doesnt hit the floor----------------------------------------------
				raiseArm(200);
				if(SensorValue[ultrasonic] < 40){
					turnRight(DEGREES90);
					turnRight(DEGREES90);
				}
				lowerArm(100);

				//drive away
				robot_state = EXITING;
				break;

			case(EXITING):
			//drive away. Don't hit walls
				driveForwards(10);
				exitDistance++;

				if(SensorValue[ultrasonic] < 20 || exitDistance > 200){
					robot_state = FINISHED;
				}
				break;

			case(FINISHED):
			//cable should be connected and robot is disconnected from cable now
				//signal completion

				for(int k = 0; k < 5; k++){
					SensorValue[led1] = 0;
					SensorValue[led2] = 1;

					SensorValue[led1] = 1;
					SensorValue[led2] = 0;
				}

				//turn sensors off
				SensorValue[led1] = 1;
				SensorValue[led2] = 1;
				jobDone = true;
				break;

			default:
			//should never get here
				break;
		}//switch

		//reset button reading
		button1_pushed = button2_pushed = false;

	}//while
}//fullExecution()

task main(){
/*	  driveForwards(1000);
		driveBackwards(1000);
		lowerArm(300);
		raiseArm(300);
*/
/*
int beacon_level;
while(true){
		beacon_level = monitorLight();	//ir sensor difference update
		if ( beacon_level > beacon_threshold ) {	//light seen
			raiseArm(10);
		}
		else{
			lowerArm(1);
		}
//SensorValue(led1) = 10;
}
*/
//actual program:
	button1_pushed = false;
	while(true){
		monitorInput();
		if(button1_pushed){
			button1_pushed = false;
			fullExecution();

		}
	}//while

}//end

/* Cheating with buttons
 * INFO
 * 		Arena is 2.5 meters squared
 * Process
 * 		Rotate to find the furthest point from the robot
 *		Drive towards that point(center of the arena idealy)
 *		Stop driving when 1.5? meters from the wall? What is the max search range?
 */

//current todo
/*
 * setup new buttons, sensors
 * adjust ir sensor values to work with the new 2 sensor setup
 * Test in exiting process that the arm doesn't smack the ground
 * test all code
 * Test EXITING and CABLE_CONNECTION code especially
 *
 * ~~~~~~Maybe need to look at~~~~~~
 * check if we want to change when leds activate
 * adjust ADJUST_SEARCH_POSITION
 * adjust turning speed
 */
