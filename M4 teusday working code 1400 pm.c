#pragma config(Sensor, in6,    ir1,            sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl6,  tabby1,         sensorTouch)
#pragma config(Sensor, dgtl7,  tabby2,         sensorTouch)
#pragma config(Sensor, dgtl4,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, I2C_2,  encoder2,       sensorNone)
#pragma config(Motor,  port2,           kindofbroken,  tmotorNone, openLoop)
#pragma config(Motor,  port3,           broken,        tmotorNone, openLoop)
#pragma config(Motor,  port4,           motor2,        tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          armAltitude,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * 2019-03-19
 */


const int beacon_threshold = 400;
//from LightDetector.c ^ for the IR sensor

//states for fullExecution()
typedef enum RobotState {
	SEARCHING = 0,
	ADJUST_SEARCH_POSITION,
	HIT_WALL_SEARCH,
	HIT_WALL_EXIT,
	APPROACHING,
	ATTACHING_CABLE,
	BEST_EXIT,
	EXITING,
	FINISHED
};

/*Clearly labeled constraints   should  indicate expected  sensor  readings  for  different
  conditions such as your robot?s proximity sensor reading when the robot is near enough
  to the beacon for target pick up
 */
int propor_proximity_to_beacon = 22; //cm reading from Ultrasonic Sensor

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input

bool tabby1_pushed = false;
bool tabby2_pushed = false;

int forwardsSpeed = -30;
int backwardsSpeed = 30;
int armSpeed = 50;
int distanceThreshhold = 22; //distance to object in front of robot. 22 cm for good beacon positioning
int DEGREES90 = 2000; //amount of time to turn 90 degrees set to 2000?
//led = 0 is on. 1 is off


/*	monitorInput()taken from lab 2 code
 *
 *  Used to flag button inputs
 *       - this avoids errors caused by program recognizing input, taking action, and
 *         reading input again before button is released
 */
void monitorInput(){
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }

  if(SensorValue(tabby1) && !tabby1_pushed){
  	tabby1_pushed = true;
	}

	if(SensorValue(tabby2) && !tabby2_pushed){
  	tabby2_pushed = true;
	}
}

/* monitorLight() - taken from lab code
 * Perform processing of measurements.
 * Should be called with rate of at least 20 Hertz for proper detection of puck.
 * Purpose: determines if the robot is facing the beacon
 */
int monitorLight(){
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = 4096 - SensorValue[ir1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}


 // <Basic Movement And Signals> //
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

/*	driveForwards()
 *	drive forwards for a set amount of time
 * 40 speed for 2700 time is about a meter
 */
void driveForwards(int amountToMove){
	resetMotorEncoder(motor1);

  motor[motor1] = forwardsSpeed;
 	motor[motor2] = forwardsSpeed - 13.5;
	wait1Msec(amountToMove);

  motor[motor1] = motor[motor2] = 0;
  button1_pushed = button2_pushed = false;
  resetMotorEncoder(motor1);
}

/*	DriveBackwards()
 *	Drive backwards for a set amount of time
 */
void driveBackwards(int amountToMove){
		resetMotorEncoder(motor1);


  	      motor[motor1] = motor[motor2] = backwardsSpeed;
//  	      motor[motor2] = backwardsSpeed;
  	      wait1Msec(amountToMove);

        motor[motor1] = motor[motor2] = 0;
        button1_pushed = button2_pushed = false;
        resetMotorEncoder(motor1);
}

/*	turnRight()
 *	Purpose: Robot turns for a set amount of time. 20 and -30 speed with 3600 time equate to a 90 degree turn
 *	Method: one motor forwards, one backwards
 */
void turnRight(int degreesToMove){

	motor[motor1] = 30;//forwards
	motor[motor2] = -30;//backwards
	wait1Msec(degreesToMove);

	motor[motor1] = 0;
	motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}

/* turnLeft()
 * opposite of turn right
 */
void turnLeft(int degreesToMove){
	motor[motor1] = -25;//left motor backwards
	motor[motor2] = 25;//forwards
	wait1Msec(degreesToMove);

    motor[motor1] = motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}

/* raiseArm()
 * Purpose: raises the arm holding the connection point of the cable for a set amount of time
 */
void raiseArm(int amountToMove){
	resetMotorEncoder(armAltitude);

  	motor[armAltitude] = armSpeed;
  	wait1Msec(amountToMove);

    motor[armAltitude] = 0;
    button1_pushed = button2_pushed = false;
    resetMotorEncoder(armAltitude);
}//raiseArm

/* lowerArm()
 * Purpose: Oposite as raiseArm
 */
void lowerArm(int amountToMove){
	resetMotorEncoder(armAltitude);

	motor[armAltitude] = -armSpeed;
  wait1Msec(amountToMove);

   motor[armAltitude] = 0;
   button1_pushed = button2_pushed = false;
   resetMotorEncoder(armAltitude);
}

/* connectCable()
 * runs through connecting the cable
 */
void connectCable(){
	//lower arm then back away so cable doesnt get stuck
	//*WARNING* cable gets stuck sometimes
	wait1Msec(1000);
	lowerArm(250);
	wait1Msec(1000);
	driveBackwards(1000);
	wait1Msec(1000);
	lowerArm(70);//lower arm after backing away from target
	wait1Msec(1000);
	button1_pushed = button2_pushed = false;
}


 // <Robot Running Functions> //
//~~~~~~~~~~~~~~~~~~~~~~~~~~~//



/* openIRSearch()
 * Purpose: Searches for the target object with one IR sensor with nothing to restrict the IR sensors field of view
 * Possibly impliment instead of default search (with straw around IR sensor) to increase range of the sensor
 * possibly just make the robot turn more after seeing the beacon. Will have conflict if the robot starts facing the beacon
 */

/* fullExecution()
 * Purpose: locate and attatch the cable to the target fully.
 */
void fullExecution(){
	bool jobDone = false; //for while loop
	RobotState robot_state = SEARCHING; //for switch case default SEARCHING
	int amountTurned = 0; //for searching
	int exitDistance = 0; //for moving away from cable after connection
	int beacon_level;
	int domTimer = 0;
	bool haveStopped = false;

	wait1Msec(100);

	while(!jobDone){
		button1_pushed = button2_pushed = false;
		monitorInput();//for buttons

		beacon_level = monitorLight();	//ir sensor difference update
				if ( beacon_level > beacon_threshold ) {	//light seen
					SensorValue(led1) = 0;
				}else SensorValue(led1) = 1;

/*		if(button1_pushed){
			button1_pushed = false;
			wait1Msec(3000);
		}
*/
		switch(robot_state){
			case(SEARCHING):
			//rotate until target seen. If no target with 360 roation then move across arena more.
				//rotate
				turnLeft(2);

				//detect target
				// Update sensor values (must be called at least 20 times a second for proper performance).
				beacon_level = monitorLight();	//ir sensor difference update
				if ( beacon_level > beacon_threshold ) {	//light seen
					int first_IR = beacon_level;
					wait1Msec(500);
					turnLeft(200);	//turn more to fix detection of the beacon early

/*
					//turns past the beacon then turns back to face the beacon
					bool reverse_search = true;
					beacon_level = monitorLight();	//ir sensor difference update
					while(reverse_search){
						if (beacon_level > first_IR - 10){
							reverse_search = false;
						}
							turnRight(10);
							beacon_level = monitorLight();	//ir sensor difference update
					}
*/

					wait1Msec(500);
					robot_state = APPROACHING;
				}//if

				//detect wall hit
				if(SensorValue[ultrasonic] < 10 && SensorValue[ultrasonic] > 0){								//to be implimented---------------------------------
					robot_state = HIT_WALL_SEARCH;
				}
				break;

			case(ADJUST_SEARCH_POSITION):
				//drive forward. Do not run into stuff
				//font led blinking

				for(int k = 0; k < 100; k++){
//					driveForwards(20);
					//detect walls
					if(SensorValue(ultrasonic) < 13 && SensorValue[ultrasonic] > 0){	//might need adjusting------------------------------
						driveBackwards(100);
						turnLeft(DEGREES90);
					}
				}//for
				turnRight(1000);
				robot_state = SEARCHING;
				break;

			case(HIT_WALL_SEARCH):
			//backup 20? cm
				driveBackwards(500);
				turnRight(1000);
				robot_state = SEARCHING;
				break;

			case(HIT_WALL_EXIT):
				//backup 20? cm
				driveBackwards(500);
				robot_state = EXITING;
				break;

			case(APPROACHING)://approach while checking for target lost

				
				//front led on
				domTimer++;
				beacon_level = monitorLight();	//ir sensor difference update
				if ( domTimer > 700 &&  beacon_level < 50)  {
					wait1Msec(200);
					turnRight(200);
					beacon_level = monitorLight();	//ir sensor difference update
					wait1Msec(200);
					domTimer = 0;
					robot_state = SEARCHING;
				}


//actual program//
//min 18 max 28 
				//if too far from target
				if(SensorValue(ultrasonic) > 26){
					haveStopped = false;
					driveForwards(2);
				}
				//if too close to target
				//back led on
				else if(SensorValue(ultrasonic) < 20 && SensorValue(ultrasonic) > 0){
					if (!haveStopped){	//stop the robot only on the first detection of too close per too close
						wait1Msec(200);
						haveStopped = true;
					}
					driveBackwards(5);
				}
				//if reached target
				else{
//
					wait1Msec(200);
					//if not in correct position
					if(SensorValue(ultrasonic) < 20 || SensorValue(ultrasonic) > 26) {
						break;
					}



					//if lost beacon//
					beacon_level = monitorLight();	//ir sensor difference update
					if ( beacon_level < beacon_threshold) {	//light lost
						SensorValue(led1) = 1;
						wait1Msec(300);
						driveBackwards(200);
						turnRight(1000);
						robot_state = SEARCHING;
					}

					//else if still in proper position

					//search for super strong ir signal?

					else{
						robot_state = ATTACHING_CABLE;
					}
				}
				break;
//ACTUAL program end



/*some botched program
			driveBackwards(5);
			break;
//Some botched program end
*/

			case(ATTACHING_CABLE):
			//connect cable
				connectCable();
				robot_state = BEST_EXIT;
				break;

			case(BEST_EXIT):
			//get away from target without being connected or tangled with the cable
				//turn left 90, if wall is within 50cm,turn right, drive away
				turnLeft(DEGREES90);

				//raise arm here to avoid reading the arm as a distance. Make sure arm doesnt hit the floor----------------------------------------------
				raiseArm(200);
				if(SensorValue[ultrasonic] < 40){
					turnRight(DEGREES90);
					turnRight(DEGREES90);
				}
				driveForwards(300);
				raiseArm(500);

				//drive away
				robot_state = EXITING;
				break;

			case(EXITING):
			//drive away. Don't hit walls
				driveForwards(10);
				exitDistance++;

				if(SensorValue[ultrasonic] < 20 || exitDistance > 200){
					robot_state = FINISHED;
				}
				break;

			case(FINISHED):
			//cable should be connected and robot is disconnected from cable now
				//signal completion

				for(int k = 0; k < 5; k++){
					SensorValue[led1] = 0;
					SensorValue[led2] = 1;

					SensorValue[led1] = 1;
					SensorValue[led2] = 0;
				}

				//turn sensors off
				SensorValue[led1] = 1;
				SensorValue[led2] = 1;
				jobDone = true;
				break;

			default:
			//should never get here
				break;
		}//switch

		//reset button reading
		button1_pushed = button2_pushed = false;

	}//while
}//fullExecution()

void detectBeaconTest(){
	int beacon_level;

	while(true){
		//killswitch
		monitorInput();
		if(button1_pushed){
			button1_pushed = false;
			wait1Msec(3000);
		}

		beacon_level = monitorLight();	//ir sensor difference update
		if ( beacon_level > beacon_threshold ) {	//light seen
			SensorValue(led1) = 0;
		}
		else{ //beacon not seen
			SensorValue(led1) = 1;
		}
	}
}

task main(){
	SensorValue(led1) = 1;


//actual program:
	button1_pushed = false;
	while(true){
		monitorInput();
		if(button1_pushed){
			button1_pushed = false;
			fullExecution();

		}
	}//while

}//actual program end


/*
 * INFO
 * 		Arena is 2.5 meters squared
 * Process
 * 		Rotate to find the furthest point from the robot
 *		Drive towards that point(center of the arena idealy)
 *		Stop driving when 1.5? meters from the wall? What is the max search range?
 */

//current todo
/*
 * setup new buttons, sensors
 * adjust ir sensor values to work with the new 2 sensor setup
 * Test in exiting process that the arm doesn't smack the ground
 * test all code
 * Test EXITING and CABLE_CONNECTION code especially
 *
 * ~~~~~~Maybe need to look at~~~~~~
 * check if we want to change when leds activate
 * adjust ADJUST_SEARCH_POSITION
 * adjust turning speed
 */
