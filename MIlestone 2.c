#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  encoder1,       sensorNone)
#pragma config(Sensor, I2C_2,  encoder2,       sensorNone)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motor2,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          armAltitude,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define EXERCISE_NUMBER 2

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int forwardsAmount = 400;
int degreesToTurn = 3600;
int forwardsSpeed = 40;
int backwardsSpeed = -40;
int armSpeed = 50;

//todo install 2 buttons
/*Milestone 2
 *Step 1: Move forward 1 meter (button press) and turn 90 degrees on command (button press) pulling cable
 *Step 2: place robot in position then activate cable connection process
 */

/*
 *monitorInput()
 *runs all the time to see if a button is pressed
 *taken from lab 2 code
 *
 */
/* monitorInput()
 *
 *  Used to flag button inputs
 *       - this avoids errors caused by program recognizing input, taking action, and
 *         reading input again before button is released
 */
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}
/*
 *driveForwards()
 *drive forward and turn on command
 *drive about 1 meter (distance not important more about strait line)
 *(min distance is 75 cm
 *avoid skidding as much as possible
 *button 1 activates this
 */
void driveForwards(int amountToMove){
	resetMotorEncoder(motor1);

  motor[motor1] = forwardsSpeed;
 	motor[motor2] = forwardsSpeed;
	wait1Msec(2700);

  motor[motor1] = motor[motor2] = 0;
  button1_pushed = button2_pushed = false;
  resetMotorEncoder(motor1);
}
/*
 *DriveBackwards()
 *Unessisary for step one of milestone 2
 *neccisary for cable connection
 */
void driveBackwards(int amountToMove){
		resetMotorEncoder(motor1);


  	      motor[motor1] = backwardsSpeed;
  	      motor[motor2] = backwardsSpeed;
  	      wait1Msec(amountToMove);

        motor[motor1] = motor[motor2] = 0;
        button1_pushed = button2_pushed = false;
        resetMotorEncoder(motor1);
}
/*
 *turnRight()
 *Milestone 2: Robot turns 90 degrees at the push of a button
 *one motor forwards, one backwards
 *use button 2 to activate
 */
void turnRight(int degreesToMove){

		motor[motor1] = 20;//forwards
		motor[motor2] = -30;//backwards
		wait1Msec(degreesToMove);

    motor[motor1] = 0;
    motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}


void turnLeft(int degreesToMove){
		motor[motor1] = -30;//left motor backwards
		motor[motor2] = 20;//forwards
		wait1Msec(degreesToMove);

    motor[motor1] = motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}
/*
 *raiseArm()
 *Purpose: raises the arm holding the connection point of the cable
 *will use hard numbers for amount to raise/lower to connect cable on target object
 *activated with button 1
 */
void raiseArm(int amountToMove){
	resetMotorEncoder(armAltitude);

  	motor[armAltitude] = armSpeed;
  	wait1Msec(amountToMove);

    motor[armAltitude] = 0;
    button1_pushed = button2_pushed = false;
    resetMotorEncoder(armAltitude);
}//raiseArm

/*
 *lowerArm()
 *Purpose: same as raiseArm
 */
void lowerArm(int amountToMove){
	resetMotorEncoder(armAltitude);

	motor[armAltitude] = -armSpeed;
  wait1Msec(amountToMove);

   motor[armAltitude] = 0;
   button1_pushed = button2_pushed = false;
   resetMotorEncoder(armAltitude);
}

/*connectCable()
 *runs through connecting the cable
 *
 */
void connectCable(){
	//add drive forward if robot needs to get a little bit closer
	//lower arm then back away so cable doesnt get stuck

	wait1Msec(1000);
	lowerArm(200);
	wait1Msec(1000);
	driveBackwards(1000);
	wait1Msec(1000);
	lowerArm(200);//lower arm after backing away from target
	wait1Msec(1000);
	turnLeft(degreesToTurn);//turn 90 degrees
	wait1Msec(1000);
	//.raiseArm(400);
	wait1Msec(1000);
	//driveForwards(300);
	button1_pushed = button2_pushed = false;
}

void armRunning(){
	while(){
		monitorInput();

		if(button1_pushed) connectCable();
		//else if(button2_pushed) raiseArm(250);
		wait1Msec(100);
		button1_pushed = button2_pushed = false;
	}
}

/*
 *the ongoing code to run the move forward and turn 90 degrees
 *currently used for milestone 2 part 1
*/
void movementRunning(){
	while(){
		monitorInput();

		if(button1_pushed) driveForwards(forwardsAmount);
		else if(button2_pushed) turnLeft(degreesToTurn);

		button1_pushed = button2_pushed = false;
	}
}

task main()
{
button1_pushed = button2_pushed = false;
	switch(EXERCISE_NUMBER){
		case 1:
			movementRunning();
			break;
		case 2:
			armRunning();
			break;
		default: //should not reach default
	}//end switch
}//end

//dont know about the encoder values read for how much to move
