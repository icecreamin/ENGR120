#pragma config(Sensor, in1,    ir1,            sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  tabby1,         sensorTouch)
#pragma config(Sensor, dgtl4,  tabby2,         sensorTouch)
#pragma config(Sensor, dgtl6,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, I2C_2,  encoder2,       sensorNone)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motor2,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          armAltitude,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* EXERCISE_NUMBER
 * 1. rotate to face target
 * 2. light led when target is too far, too close, or just right
 * 3. walls?
 */
#define EXERCISE_NUMBER 1

/*Clearly labeled constraints   should  indicate expected  sensor  readings  for  different
  conditions such as your robot?s proximity sensor reading when the robot is near enough
  to the beacon for target pick up
 */
int max_proximity_to_beacon;
int max_proximity_to_wall;

//from LightDetector.c v
typedef enum T_State {
	LIGHT_SEEN = 0,
	LIGHT_GONE
};
const int beacon_threshold = 500;
//from LightDetector.c ^

/*Functions to impliment for milestone 3
a) Turn  your  robot  towards  the  target  object.    This  function  should  operate
properly when your robot is within 1 metre of the target.
b) Signals when your robot is properly facing the target object for approach but is
too  far  away  for  cable  connection.  This  function  should  be  able  to  function
properly when your robot is within 1 metre of the target.
c) Signals  when  your  robot  is  at  the  proper  distance  and  orientation  for  cable
connection.
d) Signals when your robot has made contact with a wall when turning or moving
straight.
*/




bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input

bool tabby1_pushed = false;
bool tabby2_pushed = false;

int forwardsAmount = 400;
int degreesToTurn = 3600;
int forwardsSpeed = 20;
int backwardsSpeed = -20;
int armSpeed = 50;
int distanceThreshhold = 22; //distance to object in front of robot. idk what to set this too. 22 cm for good beacon positioning




/*	monitorInput()taken from lab 2 code
 *
 *  Used to flag button inputs
 *       - this avoids errors caused by program recognizing input, taking action, and
 *         reading input again before button is released
 */
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }

  if(SensorValue(tabby1) && !tabby1_pushed){
  	tabby1_pushed = true;
	}

	if(SensorValue(tabby2) && !tabby2_pushed){
  	tabby2_pushed = true;
	}
}

/*	driveForwards()
 *	drive forwards for a set amount of time
 * 40 speed for 2700 time is about a meter
 */
void driveForwards(int amountToMove){
	resetMotorEncoder(motor1);

  motor[motor1] = forwardsSpeed;
 	motor[motor2] = forwardsSpeed;
	wait1Msec(amountToMove);

  motor[motor1] = motor[motor2] = 0;
  button1_pushed = button2_pushed = false;
  resetMotorEncoder(motor1);
}

/*	DriveBackwards()
 *	Drive backwards for a set amount of time
 */
void driveBackwards(int amountToMove){
		resetMotorEncoder(motor1);


  	      motor[motor1] = backwardsSpeed;
  	      motor[motor2] = backwardsSpeed;
  	      wait1Msec(amountToMove);

        motor[motor1] = motor[motor2] = 0;
        button1_pushed = button2_pushed = false;
        resetMotorEncoder(motor1);
}
/*	turnRight()
 *	Purpose: Robot turns for a set amount of time. 20 and -30 speed with 3600 time equate to a 90 degree turn
 *	Method: one motor forwards, one backwards
 */
void turnRight(int degreesToMove){

		motor[motor1] = 30;//forwards
		motor[motor2] = -30;//backwards
		wait1Msec(degreesToMove);

    motor[motor1] = 0;
    motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}

/* turnLeft()
 * opposite of turn right
 */
void turnLeft(int degreesToMove){
		motor[motor1] = -30;//left motor backwards
		motor[motor2] = 30;//forwards
		wait1Msec(degreesToMove);
    motor[motor1] = motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}
/* raiseArm()
 * Purpose: raises the arm holding the connection point of the cable for a set amount of time
 */
void raiseArm(int amountToMove){
	resetMotorEncoder(armAltitude);

  	motor[armAltitude] = armSpeed;
  	wait1Msec(amountToMove);

    motor[armAltitude] = 0;
    button1_pushed = button2_pushed = false;
    resetMotorEncoder(armAltitude);
}//raiseArm

/* lowerArm()
 * Purpose: Oposite as raiseArm
 */
void lowerArm(int amountToMove){
	resetMotorEncoder(armAltitude);

	motor[armAltitude] = -armSpeed;
  wait1Msec(amountToMove);

   motor[armAltitude] = 0;
   button1_pushed = button2_pushed = false;
   resetMotorEncoder(armAltitude);
}

/* connectCable()
 * runs through connecting the cable
 */
void connectCable(){
	//lower arm then back away so cable doesnt get stuck
	//*WARNING* cable gets stuck sometimes
	wait1Msec(1000);
	lowerArm(200);
	wait1Msec(1000);
	driveBackwards(1000);
	wait1Msec(1000);
	lowerArm(200);//lower arm after backing away from target
	wait1Msec(1000);
	turnLeft(degreesToTurn);//turn 90 degrees
	wait1Msec(1000);
	//raiseArm(400);
	wait1Msec(1000);
	driveForwards(300);
	button1_pushed = button2_pushed = false;
}

/* signalFoundBeacon()
 * routine or light to signal success
 * raises and lowers arm 2x
 * call when ir found beacon and distance is too far still
 */
void signalFoundBeacon(){
		SensorValue[led1] = 0;
}

void signalInPositionForConnection(){
		SensorValue[led2] = 0;
}

void signalHitWall(){

	for(int k = 0; k < 3; k++){
		SensorValue[led1] = 0;
		SensorValue[led2] = 0;

		SensorValue[led1] = 1;
		SensorValue[led2] = 1;
	}
}


//monitorLight() - taken from lab code
// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
// Purpose: determines if the robot is facing the beacon
int monitorLight()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[ir1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}

//led = 0 is on. 1 is off
//return 0 if distance is correct, return 1 if too far, return 2 if too close
int approachBeacon(){
	int  beacon_level;
	SensorValue[led1] = 1;
	SensorValue[led2] = 1;

	while(true){

		//beacon_level = monitorLight();

		//if seeing beacon
		//if(beacon_level > beacon_threshold){//beacon_threshold == 500

			//SensorValue[led1] = 1;
			if (SensorValue[ultrasonic] > distanceThreshhold + 1){
					//too far led 1 on
				SensorValue[led1] = 0;
				SensorValue[led2] = 1;
				driveForwards(10);
			}
			else if (SensorValue[ultrasonic] < distanceThreshhold - 1){
				//too close led 2 on
				SensorValue[led1] = 1;
				SensorValue[led2] = 0;
				driveBackwards(10);
			}
			else {//(SensorValue[ultrasonic] == distanceThreshhold){
				//just right
				signalHitWall();
			}

			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
		//}//if seeing beacon

/*Used for testing just the ir sensor. A binary on or off LEDs
		else{
			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
		}
*/
	}//while

	SensorValue[led1] = 0;
	SensorValue[led2] = 0;
}

/* findTarget()
 * Purpose: locates and faces the target beacon using an ir sensor
 * Uses monitorLight()
 */
void getToTarget(){

/*
TODO
start turning. if a wall is getting close then turn the other way so it doesnt face the corner. if no beacon still found then turn all the way around
*/
	T_State robot_state = LIGHT_GONE;
	int  beacon_level;
	button1_pushed = button2_pushed = false;
	tabby1_pushed = tabby2_pushed = false;

	//kill switch
	if(button2_pushed){
		return;
	}

	while( true ) {
		monitorInput();//for buttons

		// Update sensor values (must be called at least 20 times a second for proper performance).
		beacon_level = monitorLight();	//ir sensor



		switch( robot_state ) {
		case LIGHT_GONE://turn until beacon is seen
			turnLeft(20);																				//*WARNING* possibly just activate motor rather than calling turnLeft(). turnLeft() might mess with the neccisary timing of reading light

			//handle hitting walls
			if(tabby1_pushed || tabby2_pushed){
				motor[motor1] = motor[motor2] = 0;
				driveForwards(1000);
				tabby1_pushed	= tabby2_pushed = false;
			}
			//if too close to anything, back up
			if(SensorValue(ultrasonic) < 13){
					driveBackwards(1000);
			}

			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_SEEN;
				} else {
				robot_state = LIGHT_GONE;
			}
			break;
		case LIGHT_SEEN://stop turning, signal success, approach beacon, end facing the beacon at beacon
			signalFoundBeacon();
			//approach beacon
			approachBeacon();
			break;
		default:
			// This should never happen.
			robot_state = LIGHT_GONE;

		} // switch( robot_state)

	}  // while(true)

}

void findTarget(){
/*
TODO
start turning. if a wall is getting close then turn the other way so it doesnt face the corner. if no beacon still found then turn all the way around
*/
	T_State robot_state = LIGHT_GONE;
	int  beacon_level;
	button1_pushed = button2_pushed = false;

	//kill switch
	if(button2_pushed){
		return;
	}

	while( true ) {
		monitorInput();//for buttons

		// Update sensor values (must be called at least 20 times a second for proper performance).
		beacon_level = monitorLight();	//ir sensor

		switch( robot_state ) {
		case LIGHT_GONE://turn until beacon is seen
			turnLeft(20);																				//*WARNING* possibly just activate motor rather than calling turnLeft(). turnLeft() might mess with the neccisary timing of reading light

			//handle hitting walls
			if(tabby1_pushed || tabby2_pushed){
				driveForwards(500);
			}

			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_SEEN;
				} else {
				robot_state = LIGHT_GONE;
			}
			break;
		case LIGHT_SEEN://stop turning, signal success, approach beacon, end facing the beacon at beacon
			signalFoundBeacon();
			//approach beacon
			/*
			int distanceState = detectProperDistanceReturn();
			if(distanceState == 0){

			}
			else if(distanceState == 1){
				driveForwards(10);
			}
			else if(distanceState == 2){
				driveBackwards(10);
			}
			*/

			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_SEEN;
				} else {
				robot_state = LIGHT_GONE;
			}
			break;
		default:
			// This should never happen.
			robot_state = LIGHT_GONE;

		} // switch( robot_state)

	}  // while(true)

}

//FIX TURNING
void fixTurning(){//to be deleted

	button1_pushed = button2_pushed = false;
	tabby1_pushed = false;
	tabby2_pushed = false;

int rightAmount = 30;
int leftAmount = -30;

	while( true ) {
		monitorInput();//for buttons

		if(button1_pushed){
			rightAmount += 5;
			 motor[motor1] = motor[motor2] = 0;
			 wait1Msec(500);
		}
		else if (button2_pushed){
			rightAmount -= 5;
			 motor[motor1] = motor[motor2] = 0;
			 wait1Msec(500);
		}
		else if(tabby1_pushed){
			leftAmount += 5;
			 motor[motor1] = motor[motor2] = 0;
			 wait1Msec(500);
		}
		else if (tabby2_pushed){
			leftAmount -= 5;
			 motor[motor1] = motor[motor2] = 0;
			 wait1Msec(500);
		}

		motor[motor1] = leftAmount;//left motor backwards
		motor[motor2] = rightAmount;//forwards
		 wait1Msec(20);
     button1_pushed = button2_pushed = false;																		//*WARNING* possibly just activate motor rather than calling turnLeft(). turnLeft() might mess with the neccisary timing of reading light
		 tabby1_pushed = tabby2_pushed = false;



	}  // while(true)

}

//led = 0 is on. 1 is off
void detectProperDistance(){
	int  beacon_level;
	SensorValue[led1] = 1;
	SensorValue[led2] = 1;

	while(true){
		beacon_level = monitorLight();

		//if seeing beacon
		if(beacon_level > beacon_threshold){//beacon_threshold == 500

			//SensorValue[led1] = 1;
			if (SensorValue[ultrasonic] > distanceThreshhold + 1){
					//too far led 1 on
				SensorValue[led1] = 0;
				SensorValue[led2] = 1;
			}
			else if (SensorValue[ultrasonic] < distanceThreshhold - 1){
				//too close led 2 on
				SensorValue[led1] = 1;
				SensorValue[led2] = 0;
			}
			else {//(SensorValue[ultrasonic] == distanceThreshhold){
				//just right
			SensorValue[led1] = 0;
			SensorValue[led2] = 0;
				//signalHitWall();
			}

			//SensorValue[led1] = 1;
			//SensorValue[led2] = 1;
		}//if seeing beacon
		else{
			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
	  }

/*Used for testing just the ir sensor. A binary on or off LEDs
		else{
			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
		}
*/
	}//while

	SensorValue[led1] = 0;
	SensorValue[led2] = 0;
}

//led = 0 is on. 1 is off
void almostRunIntoWall(){
	int  beacon_level;
	SensorValue[led1] = 0;
	SensorValue[led2] = 0;

	while(true){
		beacon_level = monitorLight();

		//if beacon is seen
//		if(beacon_level > beacon_threshold){
			//SensorValue[led1] = 1;
			if (SensorValue[ultrasonic] > distanceThreshhold + 1){
					//too far led 1 on
				driveForwards(1);
				SensorValue[led1] = 0;
				SensorValue[led2] = 1;
			}
			else if (SensorValue[ultrasonic] < distanceThreshhold - 1){
				//too close led 2 on
			driveBackwards(1);
				SensorValue[led1] = 1;
				SensorValue[led2] = 0;
			}
			else {//(SensorValue[ultrasonic] == distanceThreshhold){
				//just right
				SensorValue[led1] = 0;
				SensorValue[led2] = 0;
			}


//		}//if seeing beacon
	}//while

	SensorValue[led1] = 0;
	SensorValue[led2] = 0;
}

task main(){
button1_pushed = button2_pushed = false;
	switch(EXERCISE_NUMBER){
		case 1:	//turn to face beacon at button press
			while(){
				monitorInput();
				if(button1_pushed){
					findTarget();

					button1_pushed = false;
				}
				else if(button2_pushed){//end loop
					button2_pushed = false;
					break;
				}
			}
			break;
		case 2: //show if the robot knows that rotation and distance is correct
		  detectProperDistance();
			//turnLeft(10);
			break;
		case 3: //not run into walls
			almostRunIntoWall();
		case 4:
		while(true){
			monitorInput();
			if(button1_pushed){
				//fixTurning();
				getToTarget();
				button1_pushed = false;
				break;
		  }
		}
			break;
		default: //should not reach default
	}//end switch
	SensorValue[led1] = 1;
	SensorValue[led2] = 1;
}//end


//current todo
/*
 * if robot is facing wall and <20 cm from wall THEN move away until 20cm from wall
 * if butt tabby is hit THEN drive forwards and continue searching/whatever its doing
 *
 */
