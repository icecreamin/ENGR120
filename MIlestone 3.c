#pragma config(Sensor, in1,    ir1,            sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl6,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, I2C_2,  encoder2,       sensorNone)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motor2,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          armAltitude,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Clearly labeled constraints   should  indicate expected  sensor  readings  for  different
  conditions such as your robot’s proximity sensor reading when the robot is near enough
  to the beacon for target pick up
 */
int max_proximity_to_beacon;
int max_proximity_to_wall;

//from LightDetector.c v
typedef enum T_State {
	LIGHT_SEEN = 0,
	LIGHT_GONE
};
const int beacon_threshold = 500;
//from LightDetector.c ^

/*Functions to impliment for milestone 3
a) Turn  your  robot  towards  the  target  object.    This  function  should  operate
properly when your robot is within 1 metre of the target.
b) Signals when your robot is properly facing the target object for approach but is
too  far  away  for  cable  connection.  This  function  should  be  able  to  function
properly when your robot is within 1 metre of the target.
c) Signals  when  your  robot  is  at  the  proper  distance  and  orientation  for  cable
connection.
d) Signals when your robot has made contact with a wall when turning or moving
straight.
*/

/* EXERCISE_NUMBER
 * 1. rotate to face target
 * 2. light led when target is too far, too close, or just right
 * 3.
 */
#define EXERCISE_NUMBER 1


bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int forwardsAmount = 400;
int degreesToTurn = 3600;
int forwardsSpeed = 20;
int backwardsSpeed = -20;
int armSpeed = 50;
int distanceThreshhold = 22; //distance to object in front of robot. idk what to set this too. 22 cm for good beacon positioning




/*	monitorInput()taken from lab 2 code
 *
 *  Used to flag button inputs
 *       - this avoids errors caused by program recognizing input, taking action, and
 *         reading input again before button is released
 */
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

/*	driveForwards()
 *	drive forwards for a set amount of time
 * 40 speed for 2700 time is about a meter
 */
void driveForwards(int amountToMove){
	resetMotorEncoder(motor1);

  motor[motor1] = forwardsSpeed;
 	motor[motor2] = forwardsSpeed;
	wait1Msec(amountToMove);

  motor[motor1] = motor[motor2] = 0;
  button1_pushed = button2_pushed = false;
  resetMotorEncoder(motor1);
}

/*	DriveBackwards()
 *	Drive backwards for a set amount of time
 */
void driveBackwards(int amountToMove){
		resetMotorEncoder(motor1);


  	      motor[motor1] = backwardsSpeed;
  	      motor[motor2] = backwardsSpeed;
  	      wait1Msec(amountToMove);

        motor[motor1] = motor[motor2] = 0;
        button1_pushed = button2_pushed = false;
        resetMotorEncoder(motor1);
}
/*	turnRight()
 *	Purpose: Robot turns for a set amount of time. 20 and -30 speed with 3600 time equate to a 90 degree turn
 *	Method: one motor forwards, one backwards
 */
void turnRight(int degreesToMove){

		motor[motor1] = 20;//forwards
		motor[motor2] = -30;//backwards
		wait1Msec(degreesToMove);

    motor[motor1] = 0;
    motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}

/* turnLeft()
 * opposite of turn right
 */
void turnLeft(int degreesToMove){
		motor[motor1] = -30;//left motor backwards
		motor[motor2] = 20;//forwards
		wait1Msec(degreesToMove);
    motor[motor1] = motor[motor2] = 0;

    button1_pushed = button2_pushed = false;
}
/* raiseArm()
 * Purpose: raises the arm holding the connection point of the cable for a set amount of time
 */
void raiseArm(int amountToMove){
	resetMotorEncoder(armAltitude);

  	motor[armAltitude] = armSpeed;
  	wait1Msec(amountToMove);

    motor[armAltitude] = 0;
    button1_pushed = button2_pushed = false;
    resetMotorEncoder(armAltitude);
}//raiseArm

/* lowerArm()
 * Purpose: Oposite as raiseArm
 */
void lowerArm(int amountToMove){
	resetMotorEncoder(armAltitude);

	motor[armAltitude] = -armSpeed;
  wait1Msec(amountToMove);

   motor[armAltitude] = 0;
   button1_pushed = button2_pushed = false;
   resetMotorEncoder(armAltitude);
}

/* connectCable()
 * runs through connecting the cable
 */
void connectCable(){
	//lower arm then back away so cable doesnt get stuck
	//*WARNING* cable gets stuck sometimes
	wait1Msec(1000);
	lowerArm(200);
	wait1Msec(1000);
	driveBackwards(1000);
	wait1Msec(1000);
	lowerArm(200);//lower arm after backing away from target
	wait1Msec(1000);
	turnLeft(degreesToTurn);//turn 90 degrees
	wait1Msec(1000);
	//raiseArm(400);
	wait1Msec(1000);
	driveForwards(300);
	button1_pushed = button2_pushed = false;
}

/* signalFoundBeacon()
 * routine or light to signal success
 * raises and lowers arm 2x
 * call when ir found beacon and distance is too far still
 */
void signalFoundBeacon(){
		SensorValue[led1] = 0;
}

void signalInPositionForConnection(){
		SensorValue[led2] = 0;
}

void signalHitWall(){

}

/* detectLight()
 * Purpose: determines if the robot is facing the beacon
 *
 */
void detectLight(){
	//replaced by monitorLight
}

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLight()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[ir1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}

/* findTarget()
 * Purpose: locates and faces the target beacon using an ir sensor
 * Uses monitorLight()
 */
void findTarget(){

/*
TODO
start turning. if a wall is getting close then turn the other way so it doesnt face the corner. if no beacon still found then turn all the way around
*/
	T_State robot_state = LIGHT_GONE;
	int  beacon_level;

	while( true ) {

		// Update sensor values (must be called at least 20 times a second for proper performance).
		beacon_level = monitorLight();	//ir sensor

		switch( robot_state ) {
		case LIGHT_GONE://turn until beacon is seen
			turnLeft(20);																				//*WARNING* possibly just activate motor rather than calling turnLeft(). turnLeft() might mess with the neccisary timing of reading light
			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_SEEN;
				} else {
				robot_state = LIGHT_GONE;
			}
			break;
		case LIGHT_SEEN://stop turning, signal success, end facing the beacon
			signalFoundBeacon();
			return;
			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_SEEN;
				} else {
				robot_state = LIGHT_GONE;
			}
			break;
		default:
			// This should never happen.
			robot_state = LIGHT_GONE;

		} // switch( robot_state)

	}  // while(true)

}

//led = 0 is on. 1 is off
void detectProperDistance(){
	int  beacon_level;
	SensorValue[led1] = 0;
	SensorValue[led2] = 0;

	while(true){
		beacon_level = monitorLight();

		//if seeing beacon
		if(beacon_level > beacon_threshold){//beacon_threshold == 500

			//SensorValue[led1] = 1;
			if (SensorValue[ultrasonic] > distanceThreshhold + 1){
					//too far led 1 on
				SensorValue[led1] = 0;
				SensorValue[led2] = 1;
			}
			else if (SensorValue[ultrasonic] < distanceThreshhold - 1){
				//too close led 2 on
				SensorValue[led1] = 1;
				SensorValue[led2] = 0;
			}
			else {//(SensorValue[ultrasonic] == distanceThreshhold){
				//just right
				SensorValue[led1] = 0;
				SensorValue[led2] = 0;
			}

			SensorValue[led1] = 0;
			SensorValue[led2] = 0;
		}//if seeing beacon

/*Used for testing just the ir sensor. A binary on or off LEDs
		else{
			SensorValue[led1] = 1;
			SensorValue[led2] = 1;
		}
*/
	}//while

	SensorValue[led1] = 0;
	SensorValue[led2] = 0;
}

//led = 0 is on. 1 is off
void almostRunIntoWall(){
	int  beacon_level;
	SensorValue[led1] = 0;
	SensorValue[led2] = 0;

	while(true){
		beacon_level = monitorLight();

		//if beacon is seen
//		if(beacon_level > beacon_threshold){
			//SensorValue[led1] = 1;
			if (SensorValue[ultrasonic] > distanceThreshhold + 1){
					//too far led 1 on
				driveForwards(1);
				SensorValue[led1] = 0;
				SensorValue[led2] = 1;
			}
			else if (SensorValue[ultrasonic] < distanceThreshhold - 1){
				//too close led 2 on
			driveBackwards(1);
				SensorValue[led1] = 1;
				SensorValue[led2] = 0;
			}
			else {//(SensorValue[ultrasonic] == distanceThreshhold){
				//just right
				SensorValue[led1] = 0;
				SensorValue[led2] = 0;
			}


//		}//if seeing beacon
	}//while

	SensorValue[led1] = 0;
	SensorValue[led2] = 0;
}

task main(){
button1_pushed = button2_pushed = false;
	switch(EXERCISE_NUMBER){
		case 1:
			findTarget();
			break;
		case 2:
			//almostRunIntoWall();
		  detectProperDistance();
			//turnLeft(10);
			break;
		case 3:

			break;
		default: //should not reach default
	}//end switch
	SensorValue[led1] = 1;
	SensorValue[led2] = 1;
}//end

//dont know about the encoder values read for how much to move
